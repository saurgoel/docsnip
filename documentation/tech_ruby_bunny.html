
  <html>
    <head>
      <style>
        body {font-family: Tahoma, Geneva, sans-serif; font-size: 14px; line-height: 20px;}
        div.container{ width: 1040px; margin: 0 auto; }
        h1 {font-size: 20px; color: #777;text-transform: capitalize; font-family: 'Open Sans', sans-serif;}
        p {color: #777;background: #EEE; margin: 0px; padding: 7px 10px;}
      </style>
    </head>
    <body>
      <div class='container'>
        <p>A dead easy to use RabbitMQ Ruby client. Now feature complete.
</p><p>Bunny is a popular, easy to use, well-maintained Ruby client for RabbitMQ (3.3+)
</p><h1> all information about bunny
</h1><h1> publishing and subscribing
</h1><h1> setting up queues and exchagnes
</h1><h1> http://rubybunny.info/articles/getting_started.html
</h1><h1> Bunny creates a calss
</h1><p>Bunny
</p><p>Bunny::VERSION
</p><h1> Make sure rabbit mq server is running. Bunny has a client.
</h1><h1> Basic 1:1 example
</h1><p>conn = Bunny.new
</p><p>conn.start
</p><h1> The connection gets started. This can be seen in the rabbit mq management dashboard.
</h1><p>ch = conn.create_channel
</p><p>q  = ch.queue("bunny.examples.hello_world", :auto_delete => true)
</p><p>x  = ch.default_exchange
</p><p>q.subscribe do |delivery_info, metadata, payload|
</p><p>  puts "Received #{payload}"
</p><p>end
</p><p>x.publish("Hello!", :routing_key => q.name)
</p><p>sleep 1.0
</p><p>conn.close
</p><h1> message is always publoished to exchange
</h1><h1> a routing key may also be provided
</h1><p>http://codetunes.com/2014/event-sourcing-on-rails-with-rabbitmq/
</p><p>http://blog.brianploetz.com/post/36886084370/producing-amqp-messages-from-ruby-on-rails#
</p><p>http://rubybunny.info/articles/getting_started.html
</p>
      </div>
    </body>
  </html>